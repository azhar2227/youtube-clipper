<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Clipper Pro ‚Äî Final Production Version</title>
    <style>
        :root { --primary: #ff0000; --dark: #111; --light: #f9f9f9; }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        body { background: var(--dark); color: white; padding: 20px; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin: 20px 0; color: var(--primary); }
        input, button { padding: 12px; margin: 10px 0; width: 100%; border-radius: 8px; border: 1px solid #444; background: #222; color: white; font-size: 16px; }
        button { background: var(--primary); cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .status { margin: 20px 0; padding: 15px; background: #333; border-radius: 8px; display: none; }
        .clips-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .clip-card { background: #222; padding: 15px; border-radius: 10px; position: relative; }
        video { width: 100%; border-radius: 8px; background: black; margin: 10px 0; }
        .clip-actions { display: flex; gap: 10px; margin-top: 10px; }
        .clip-actions button { flex: 1; padding: 8px; font-size: 14px; }
        .seo-section { margin-top: 40px; background: #333; padding: 20px; border-radius: 10px; }
        textarea { width: 100%; height: 100px; margin: 10px 0; background: #111; color: white; padding: 10px; border-radius: 5px; }
        .formats { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        .formats button { flex: 1; min-width: 100px; }
        .progress-bar { width: 100%; height: 10px; background: #333; border-radius: 5px; margin: 10px 0; display: none; }
        .progress-bar div { height: 100%; background: var(--primary); border-radius: 5px; width: 0%; transition: width 0.3s; }
        @media (max-width: 768px) { .clips-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• YouTube Clipper Pro ‚Äî 100% Working</h1>
        <p>Paste YouTube URL ‚Üí Get 30s clips + AI SEO ‚Üí All Free. Secure & No Errors.</p>
        
        <input type="text" id="videoUrl" placeholder="https://www.youtube.com/watch?v=..." />
        <button id="processBtn">Process Video</button>
        
        <div class="progress-bar" id="progressBar"><div id="progressFill"></div></div>
        <div class="status" id="statusMsg"></div>

        <div id="clipsContainer" class="clips-container"></div>

        <div class="seo-section" id="seoSection" style="display:none;">
            <h3>ü§ñ AI-Generated SEO Metadata (Secure API Call)</h3>
            <div>
                <label>Title</label>
                <textarea id="seoTitle" readonly></textarea>
                <button onclick="copyText('seoTitle')">üìã Copy</button>
            </div>
            <div>
                <label>Description</label>
                <textarea id="seoDesc" readonly></textarea>
                <button onclick="copyText('seoDesc')">üìã Copy</button>
            </div>
            <div>
                <label>Tags & Hashtags</label>
                <textarea id="seoTags" readonly></textarea>
                <button onclick="copyText('seoTags')">üìã Copy</button>
            </div>
            <button id="downloadAllBtn" style="margin-top:15px;">‚¨áÔ∏è Download All Clips (ZIP)</button>
        </div>
    </div>

    <!-- Load FFmpeg -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.11.0/dist/ffmpeg-util.min.js"></script>
    
    <script>
        // ======================
        // CONFIG ‚Äî REPLACE "your-subdomain" WITH YOUR CLOUDFLARE WORKER SUBDOMAIN
        // ======================
        const WORKER_BASE_URL = "https://youtube-clipper-final.ujalaconsultant.workers.dev";

        // ======================
        // DOM ELEMENTS
        // ======================
        const videoUrlInput = document.getElementById('videoUrl');
        const processBtn = document.getElementById('processBtn');
        const statusMsg = document.getElementById('statusMsg');
        const clipsContainer = document.getElementById('clipsContainer');
        const seoSection = document.getElementById('seoSection');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        // ======================
        // EVENT LISTENERS
        // ======================
        processBtn.addEventListener('click', processVideo);
        downloadAllBtn.addEventListener('click', downloadAllClips);

        // ======================
        // MAIN FUNCTIONS
        // ======================

        async function processVideo() {
            const url = videoUrlInput.value.trim();
            if (!url) return showError("Please enter a YouTube URL.");
            
            showStatus("‚è≥ Fetching video via Secure Worker...");
            showProgressBar();

            try {
                // ‚úÖ VIDEO DOWNLOAD VIA WORKER
                const workerDownloadUrl = `${WORKER_BASE_URL}/download?url=${encodeURIComponent(url)}`;
                
                const response = await fetch(workerDownloadUrl);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `Server returned ${response.status}`);
                }
                
                const videoBlob = await response.blob();
                const videoDuration = await getVideoDuration(videoBlob);

                if (videoDuration < 30) {
                    showError("Video is less than 30 seconds. Cannot slice.");
                    return;
                }

                // Slice video into 30s clips
                await sliceVideoIntoClips(videoBlob, videoDuration);

                // ‚úÖ AI SEO ‚Äî VIA SECURE WORKER
                await generateSEOMetadata(url);

                hideProgressBar();
                showStatus("‚úÖ Processing complete! Scroll down to view clips & SEO data.", "success");

            } catch (err) {
                hideProgressBar();
                showError("Error: " + err.message);
                console.error(err);
            }
        }

        async function getVideoDuration(blob) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.onloadedmetadata = () => {
                    resolve(video.duration);
                    video.remove();
                };
                video.src = URL.createObjectURL(blob);
            });
        }

        async function sliceVideoIntoClips(blob, duration) {
            const ffmpeg = new FFmpeg();
            await ffmpeg.load();

            clipsContainer.innerHTML = '';
            const clips = [];
            const totalClips = Math.ceil(duration / 30);

            for (let i = 0; i < totalClips; i++) {
                const start = i * 30;
                const end = Math.min(start + 30, duration);
                const clipName = `clip_${i+1}.mp4`;

                showStatus(`‚úÇÔ∏è Slicing clip ${i+1} of ${totalClips}...`);

                await ffmpeg.writeFile('input.mp4', await fetchFile(blob));
                await ffmpeg.exec([
                    '-i', 'input.mp4',
                    '-ss', start.toString(),
                    '-to', end.toString(),
                    '-c:v', 'libx264',
                    '-c:a', 'aac',
                    '-vf', 'scale=1280:720',
                    '-preset', 'ultrafast',
                    clipName
                ]);

                const clipData = await ffmpeg.readFile(clipName);
                const clipBlob = new Blob([clipData.buffer], { type: 'video/mp4' });
                const clipUrl = URL.createObjectURL(clipBlob);

                clips.push({ id: i+1, blob: clipBlob, url: clipUrl, name: clipName });

                createClipCard(clipUrl, i+1, start, end, clipBlob, clipName);
                updateProgress((i + 1) / totalClips);
            }
        }

        function createClipCard(url, id, start, end, blob, filename) {
            const card = document.createElement('div');
            card.className = 'clip-card';
            card.innerHTML = `
                <h4>Clip #${id} [${formatTime(start)} - ${formatTime(end)}]</h4>
                <video controls>
                    <source src="${url}" type="video/mp4">
                </video>
                <div class="clip-actions">
                    <button onclick="downloadFile('${url}', '${filename}')">‚¨áÔ∏è MP4</button>
                    <button onclick="convertAndDownload('${url}', '${filename}', 'mp3')">üîä MP3</button>
                    <button onclick="convertAndDownload('${url}', '${filename}', 'webm')">üé• WebM</button>
                </div>
            `;
            clipsContainer.appendChild(card);
        }

        async function generateSEOMetadata(videoUrl) {
            try {
                showStatus("üß† Generating SEO metadata via Secure AI API...");

                // ‚úÖ CALL SECURE WORKER
                const seoUrl = `${WORKER_BASE_URL}/seo?url=${encodeURIComponent(videoUrl)}`;
                const response = await fetch(seoUrl);
                const seoData = await response.json();

                document.getElementById('seoTitle').value = seoData.title;
                document.getElementById('seoDesc').value = seoData.description;
                document.getElementById('seoTags').value = `${seoData.tags}, ${seoData.hashtags}`;

                seoSection.style.display = 'block';
                showStatus("‚úÖ SEO Metadata Generated!", "success");

            } catch (err) {
                console.error("SEO Error:", err);
                document.getElementById('seoTitle').value = "YouTube Clip Title";
                document.getElementById('seoDesc').value = "Download this 30-second clip and share!";
                document.getElementById('seoTags').value = "youtube,shorts,clip,free,download";
                seoSection.style.display = 'block';
            }
        }

        // ======================
        // DOWNLOAD & CONVERSION
        // ======================

        function downloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
        }

        async function convertAndDownload(videoUrl, filename, format) {
            const ffmpeg = new FFmpeg();
            await ffmpeg.load();
            await ffmpeg.writeFile('input.mp4', await (await fetch(videoUrl)).arrayBuffer());

            let args, ext, mime;
            if (format === 'mp3') {
                args = ['-i', 'input.mp4', '-vn', '-ar', '44100', '-ac', '2', '-b:a', '192k', 'output.mp3'];
                ext = '.mp3';
                mime = 'audio/mp3';
            } else if (format === 'webm') {
                args = ['-i', 'input.mp4', '-c:v', 'libvpx-vp9', '-c:a', 'libopus', 'output.webm'];
                ext = '.webm';
                mime = 'video/webm';
            }

            await ffmpeg.exec(args);
            const data = await ffmpeg.readFile(`output${ext}`);
            const blob = new Blob([data.buffer], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.replace('.mp4', ext);
            a.click();
        }

        async function downloadAllClips() {
            const JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default;
            const zip = new JSZip();

            Array.from(clipsContainer.querySelectorAll('.clip-card')).forEach((card, index) => {
                const videoUrl = card.querySelector('video source').src;
                const filename = `clip_${index+1}.mp4`;
                zip.file(filename, fetch(videoUrl));
            });

            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'youtube_clips.zip';
            a.click();
        }

        // ======================
        // HELPERS
        // ======================

        function copyText(elementId) {
            const el = document.getElementById(elementId);
            el.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        }

        function showStatus(msg, type = 'info') {
            statusMsg.style.display = 'block';
            statusMsg.textContent = msg;
            statusMsg.style.color = type === 'success' ? 'lightgreen' : 'orange';
        }

        function showError(msg) {
            showStatus("‚ùå " + msg, 'error');
        }

        function showProgressBar() {
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
        }

        function hideProgressBar() {
            progressBar.style.display = 'none';
        }

        function updateProgress(ratio) {
            progressFill.style.width = `${ratio * 100}%`;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return [h, m, s].filter((v, i) => v > 0 || i > 0).map(v => v.toString().padStart(2, '0')).join(':');
        }

        async function fetchFile(blob) {
            const buffer = await blob.arrayBuffer();
            return new Uint8Array(buffer);
        }
    </script>
</body>
</html>



