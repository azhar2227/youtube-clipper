<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Clipper Pro ‚Äî Client-Side Magic</title>
    <style>
        :root { --primary: #ff0000; --dark: #111; --light: #f9f9f9; }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        body { background: var(--dark); color: white; padding: 20px; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin: 20px 0; color: var(--primary); }
        input, button { padding: 12px; margin: 10px 0; width: 100%; border-radius: 8px; border: 1px solid #444; background: #222; color: white; font-size: 16px; }
        button { background: var(--primary); cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .status { margin: 20px 0; padding: 15px; background: #333; border-radius: 8px; display: none; }
        .clips-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .clip-card { background: #222; padding: 15px; border-radius: 10px; position: relative; }
        video { width: 100%; border-radius: 8px; background: black; margin: 10px 0; }
        .clip-actions { display: flex; gap: 10px; margin-top: 10px; }
        .clip-actions button { flex: 1; padding: 8px; font-size: 14px; }
        .seo-section { margin-top: 40px; background: #333; padding: 20px; border-radius: 10px; }
        textarea { width: 100%; height: 100px; margin: 10px 0; background: #111; color: white; padding: 10px; border-radius: 5px; }
        .formats { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        .formats button { flex: 1; min-width: 100px; }
        .progress-bar { width: 100%; height: 10px; background: #333; border-radius: 5px; margin: 10px 0; display: none; }
        .progress-bar div { height: 100%; background: var(--primary); border-radius: 5px; width: 0%; transition: width 0.3s; }
        @media (max-width: 768px) { .clips-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• YouTube Clipper Pro ‚Äî 100% Client-Side</h1>
        <p>Paste YouTube URL ‚Üí Get 30s clips + AI SEO ‚Üí All Free. No Server Needed.</p>
        
        <input type="text" id="videoUrl" placeholder="https://www.youtube.com/watch?v=..." />
        <button id="processBtn">Process Video</button>
        
        <div class="progress-bar" id="progressBar"><div id="progressFill"></div></div>
        <div class="status" id="statusMsg"></div>

        <div id="clipsContainer" class="clips-container"></div>

        <div class="seo-section" id="seoSection" style="display:none;">
            <h3>ü§ñ AI-Generated SEO Metadata (via Gemini)</h3>
            <div>
                <label>Title</label>
                <textarea id="seoTitle" readonly></textarea>
                <button onclick="copyText('seoTitle')">üìã Copy</button>
            </div>
            <div>
                <label>Description</label>
                <textarea id="seoDesc" readonly></textarea>
                <button onclick="copyText('seoDesc')">üìã Copy</button>
            </div>
            <div>
                <label>Tags & Hashtags</label>
                <textarea id="seoTags" readonly></textarea>
                <button onclick="copyText('seoTags')">üìã Copy</button>
            </div>
            <button id="downloadAllBtn" style="margin-top:15px;">‚¨áÔ∏è Download All Clips (ZIP)</button>
        </div>
    </div>

    <!-- Load FFmpeg & yt-dlp.js -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.11.0/dist/ffmpeg-util.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ytdl-wasm@1.0.4/dist/ytdl-wasm.min.js"></script>
    <script>
        // ======================
        // CONFIG ‚Äî ONLY FOR SEO (VIDEO IS CLIENT-SIDE)
        // ======================
        
        // ======================
        // DOM ELEMENTS
        // ======================
        const videoUrlInput = document.getElementById('videoUrl');
        const processBtn = document.getElementById('processBtn');
        const statusMsg = document.getElementById('statusMsg');
        const clipsContainer = document.getElementById('clipsContainer');
        const seoSection = document.getElementById('seoSection');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        // ======================
        // EVENT LISTENERS
        // ======================
        processBtn.addEventListener('click', processVideo);
        downloadAllBtn.addEventListener('click', downloadAllClips);

        // ======================
        // MAIN FUNCTIONS
        // ======================

        async function processVideo() {
            const url = videoUrlInput.value.trim();
            if (!url) return showError("Please enter a YouTube URL.");
            
            showStatus("‚è≥ Initializing YouTube-DL... DO NOT REFRESH.");
            showProgressBar();

            try {
                // ‚úÖ CLIENT-SIDE VIDEO DOWNLOAD ‚Äî NO WORKER NEEDED
                const ytdl = await YtdlWasm();
                showStatus("üì• Downloading video from YouTube...");

                const videoInfo = await ytdl.getInfo(url);
                const bestFormat = videoInfo.formats.find(f => f.ext === "mp4" && f.resolution === "720p") || videoInfo.formats.find(f => f.ext === "mp4") || videoInfo.formats[0];

                const response = await fetch(bestFormat.url);
                const videoBlob = await response.blob();
                const videoDuration = await getVideoDuration(videoBlob);

                if (videoDuration < 30) {
                    showError("Video is less than 30 seconds. Cannot slice.");
                    return;
                }

                // Slice video into 30s clips
                await sliceVideoIntoClips(videoBlob, videoDuration);

                // ‚úÖ AI SEO ‚Äî Still via Gemini (you can move this to client-side too if needed)
                await generateSEOMetadata(url);

                hideProgressBar();
                showStatus("‚úÖ Processing complete! Scroll down to view clips & SEO data.", "success");

            } catch (err) {
                hideProgressBar();
                showError("Error: " + err.message);
                console.error(err);
            }
        }

        async function getVideoDuration(blob) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.onloadedmetadata = () => {
                    resolve(video.duration);
                    video.remove();
                };
                video.src = URL.createObjectURL(blob);
            });
        }

        async function sliceVideoIntoClips(blob, duration) {
            const ffmpeg = new FFmpeg();
            await ffmpeg.load();

            clipsContainer.innerHTML = '';
            const clips = [];
            const totalClips = Math.ceil(duration / 30);

            for (let i = 0; i < totalClips; i++) {
                const start = i * 30;
                const end = Math.min(start + 30, duration);
                const clipName = `clip_${i+1}.mp4`;

                showStatus(`‚úÇÔ∏è Slicing clip ${i+1} of ${totalClips}...`);

                await ffmpeg.writeFile('input.mp4', await fetchFile(blob));
                await ffmpeg.exec([
                    '-i', 'input.mp4',
                    '-ss', start.toString(),
                    '-to', end.toString(),
                    '-c:v', 'libx264',
                    '-c:a', 'aac',
                    '-vf', 'scale=1280:720',
                    '-preset', 'ultrafast',
                    clipName
                ]);

                const clipData = await ffmpeg.readFile(clipName);
                const clipBlob = new Blob([clipData.buffer], { type: 'video/mp4' });
                const clipUrl = URL.createObjectURL(clipBlob);

                clips.push({ id: i+1, blob: clipBlob, url: clipUrl, name: clipName });

                createClipCard(clipUrl, i+1, start, end, clipBlob, clipName);
                updateProgress((i + 1) / totalClips);
            }
        }

        function createClipCard(url, id, start, end, blob, filename) {
            const card = document.createElement('div');
            card.className = 'clip-card';
            card.innerHTML = `
                <h4>Clip #${id} [${formatTime(start)} - ${formatTime(end)}]</h4>
                <video controls>
                    <source src="${url}" type="video/mp4">
                </video>
                <div class="clip-actions">
                    <button onclick="downloadFile('${url}', '${filename}')">‚¨áÔ∏è MP4</button>
                    <button onclick="convertAndDownload('${url}', '${filename}', 'mp3')">üîä MP3</button>
                    <button onclick="convertAndDownload('${url}', '${filename}', 'webm')">üé• WebM</button>
                </div>
            `;
            clipsContainer.appendChild(card);
        }

        async function generateSEOMetadata(videoUrl) {
    try {
        showStatus("üß† Generating SEO metadata via Secure AI API...");

        // ‚úÖ CALL SECURE WORKER ‚Äî API KEY NEVER EXPOSED
        const workerSeoUrl = `https://youtube-clipper-ai-seo.your-subdomain.workers.dev/seo?url=${encodeURIComponent(videoUrl)}`;
        
        const response = await fetch(workerSeoUrl);
        const seoData = await response.json();

        document.getElementById('seoTitle').value = seoData.title;
        document.getElementById('seoDesc').value = seoData.description;
        document.getElementById('seoTags').value = `${seoData.tags}, ${seoData.hashtags}`;

        seoSection.style.display = 'block';
        showStatus("‚úÖ SEO Metadata Generated!", "success");

    } catch (err) {
        console.error("SEO Error:", err);
        document.getElementById('seoTitle').value = "YouTube Clip Title";
        document.getElementById('seoDesc').value = "Download this 30-second clip and share!";
        document.getElementById('seoTags').value = "youtube,shorts,clip,free,download";
        seoSection.style.display = 'block';
    }
}

        // ======================
        // HELPERS
        // ======================

        function copyText(elementId) {
            const el = document.getElementById(elementId);
            el.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        }

        function showStatus(msg, type = 'info') {
            statusMsg.style.display = 'block';
            statusMsg.textContent = msg;
            statusMsg.style.color = type === 'success' ? 'lightgreen' : 'orange';
        }

        function showError(msg) {
            showStatus("‚ùå " + msg, 'error');
        }

        function showProgressBar() {
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
        }

        function hideProgressBar() {
            progressBar.style.display = 'none';
        }

        function updateProgress(ratio) {
            progressFill.style.width = `${ratio * 100}%`;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return [h, m, s].filter((v, i) => v > 0 || i > 0).map(v => v.toString().padStart(2, '0')).join(':');
        }

        async function fetchFile(blob) {
            const buffer = await blob.arrayBuffer();
            return new Uint8Array(buffer);
        }

        function extractBetween(text, start, end) {
            const s = text.indexOf(start) + start.length;
            const e = text.indexOf(end, s);
            return e === -1 ? "" : text.substring(s, e).trim();
        }

        function extractAfter(text, marker) {
            const s = text.indexOf(marker) + marker.length;
            return s === -1 ? "" : text.substring(s).trim();
        }

        function clean(str) {
            return str.replace(/^[#*:>\s]+|[\\#*:>\s]+$/g, '').trim();
        }
    </script>
</body>
</html>